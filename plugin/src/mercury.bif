module Mercury;

%%{
#include <cstddef>
#include <span>
#include <set>
#include <format>

#include "zeek/packet_analysis/Manager.h"

struct VarintRes {
	uint64_t value;
	uint64_t raw_value; // raw value, not removing the varint prefix
	size_t length;
};

// Algorithm from RFC 9000 Appendix A.1
std::optional<VarintRes> ReadVarint(std::span<const std::byte> data) {
	if ( data.empty() )
		return std::nullopt;

	const std::byte first_byte = data[0];

	// first two bits encode length
	const uint8_t prefix = std::to_integer<uint8_t>(first_byte) >> 6;
	const size_t length = 1 << prefix;

	if ( data.size() < length )
		return std::nullopt;

	uint64_t value = std::to_integer<uint8_t>(first_byte) & 0x3F;
  uint64_t raw_value = std::to_integer<uint8_t>(first_byte);

	for ( size_t i = 1; i < length; ++i )
		{
		const auto cd = std::to_integer<uint8_t>(data[i]);
		value = ( value << 8 ) | cd;
		raw_value = ( raw_value << 8 ) | cd;
		}

	return VarintRes{
		.value = value,
		.raw_value = raw_value,
		.length = length
	};
}

%%}

## Decode quic_transport_parameters and return a list of them as a string vector
## Grease values are converted to 1b
## Vector is sorted
function quic_transport_parameter%(ext: string%): string_vec
	%{
	auto result = zeek::make_intrusive<zeek::VectorVal>(zeek::id::string_vec);

	std::multiset<uint64_t> parameter_ids;
	const u_char* ext_val = ext->Bytes();
	unsigned int length = ext->Len();

	std::span<const u_char> source_span(ext_val, length);
	std::span<const std::byte> buffer = std::as_bytes(source_span);

	while ( ! buffer.empty() ) {
		// RFC 9000 Section 18:
		// Transport Parameter {
		//  Transport Parameter ID (i),
		//  Transport Parameter Length (i),
		//  Transport Parameter Value (..),
		// }

		// FIXME: this is a workaround for the fact that the mercury implementation uses
		// a combination of numbers with and without the prefix for the fingerprint
		auto tp_id = ReadVarint(buffer);

		if ( ! tp_id )
			return result;

		// degrease
		if ( tp_id->value % 31 == 27 ) // for degreasing - use the actual value
			parameter_ids.insert(27);
		else
			parameter_ids.insert(tp_id->raw_value); // but for adding, use the one with prefix

		buffer = buffer.subspan(tp_id->length);

		auto tp_length = ReadVarint(buffer);

		if ( ! length )
			return result;

		// have to skip length of lenth field, plus length of value
		if ( buffer.size() < tp_length->value + tp_length->length )
			return result;

		buffer = buffer.subspan(tp_length->value + tp_length->length);
	}

	for ( auto const &id : parameter_ids )
		{
		// Probably will have to change this for older distributions.
		result->Append(zeek::make_intrusive<zeek::StringVal>(std::format("({:02x})", id)));
		}

	return result;
	%}

function tcp_option_list%(%): Mercury::mercury_tcp_option_list
	%{
	static auto mercury_tcp_option_list = zeek::id::find_type<zeek::VectorType>("Mercury::mercury_tcp_option_list");
	auto result = zeek::make_intrusive<zeek::VectorVal>(mercury_tcp_option_list);

	static const auto& analyzer = zeek::packet_mgr->GetAnalyzer("TCP");
	auto spans = zeek::packet_mgr->GetAnalyzerData(analyzer);

	if ( spans.empty() || spans[0].size() < sizeof(struct tcphdr) )
		return result;

	const auto* tcp_hdr = reinterpret_cast<const struct tcphdr*>(spans[0].data());
	size_t tcp_header_size = static_cast<size_t>(tcp_hdr->th_off) * 4;

	if ( ( tcp_header_size < sizeof(struct tcphdr) ) || ( tcp_header_size > spans[0].size() ) )
		return result;

	const auto* options_start = reinterpret_cast<const std::byte*>(tcp_hdr) + sizeof(struct tcphdr);
	const auto* options_end = reinterpret_cast<const std::byte*>(tcp_hdr) + tcp_header_size;

	assert(options_start <= options_end);

	std::span<const std::byte> remaining_options(options_start, options_end);

	static auto mercury_tcp_option = zeek::id::find_type<zeek::RecordType>("Mercury::mercury_tcp_option");

	while ( !remaining_options.empty() ) {
		const auto opt = static_cast<uint8_t>(remaining_options[0]);
		std::span<const std::byte> current_option_data = {};

		size_t opt_len;

		if ( opt < 2 )
			opt_len = 1;
		else if ( remaining_options.size() < 2 )
			// We've run off the end, no room for the length.
			break;
		else
			opt_len = static_cast<size_t>(remaining_options[1]);

		if ( opt_len == 0 )
				break; // trashed length field

		if ( opt_len > remaining_options.size()  )
				// No room for rest of option.
				break;

		if ( opt_len > 2 )
			current_option_data = remaining_options.subspan(2, opt_len-2);
		remaining_options = remaining_options.subspan(opt_len);

		auto r = make_intrusive<RecordVal>(mercury_tcp_option);
		r->Assign(0, opt);
		r->Assign(1, zeek::make_intrusive<zeek::StringVal>(current_option_data.size(), reinterpret_cast<const char*>(current_option_data.data())));
		result->Append(r);

		// if ( opt == TCPOPT_EOL )
		//	// All done - could flag if more junk left over ....
		//	break;
    }

	return result;
	%}
