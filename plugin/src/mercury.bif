module Mercury;

%%{
#include <cstddef>
#include <span>
#include <set>
#include <format>


struct VarintRes {
	uint64_t value;
	uint64_t raw_value; // raw value, not removing the varint prefix
	size_t length;
};

// Algorithm from RFC 9000 Appendix A.1
std::optional<VarintRes> ReadVarint(std::span<const std::byte> data) {
	if ( data.empty() )
		return std::nullopt;

	const std::byte first_byte = data[0];

	// first two bits encode length
	const uint8_t prefix = std::to_integer<uint8_t>(first_byte) >> 6;
	const size_t length = 1 << prefix;

	if ( data.size() < length )
		return std::nullopt;

	uint64_t value = std::to_integer<uint8_t>(first_byte) & 0x3F;
  uint64_t raw_value = std::to_integer<uint8_t>(first_byte);

	for ( size_t i = 1; i < length; ++i )
		{
		const auto cd = std::to_integer<uint8_t>(data[i]);
		value = ( value << 8 ) | cd;
		raw_value = ( raw_value << 8 ) | cd;
		}

	return VarintRes{
		.value = value,
		.raw_value = raw_value,
		.length = length
	};
}

%%}

## Decode quic_transport_parameters and return a list of them as a string vector
## Grease values are converted to 1b
## Vector is sorted
function quic_transport_parameter%(ext: string%): string_vec
	%{
	auto result = zeek::make_intrusive<zeek::VectorVal>(zeek::id::string_vec);

	std::multiset<uint64_t> parameter_ids;
	const u_char* ext_val = ext->Bytes();
	unsigned int length = ext->Len();

	std::span<const u_char> source_span(ext_val, length);
	std::span<const std::byte> buffer = std::as_bytes(source_span);

	while ( ! buffer.empty() ) {
		// RFC 9000 Section 18:
		// Transport Parameter {
		//  Transport Parameter ID (i),
		//  Transport Parameter Length (i),
		//  Transport Parameter Value (..),
		// }

		// FIXME: this is a workaround for the fact that the mercury implementation uses
		// a combination of numbers with and without the prefix for the fingerprint
		auto tp_id = ReadVarint(buffer);

		if ( ! tp_id )
			return result;

		// degrease
		if ( tp_id->value % 31 == 27 ) // for degreasing - use the actual value
			parameter_ids.insert(27);
		else
			parameter_ids.insert(tp_id->raw_value); // but for adding, use the one with prefix

		buffer = buffer.subspan(tp_id->length);

		auto tp_length = ReadVarint(buffer);

		if ( ! length )
			return result;

		// have to skip length of lenth field, plus length of value
		if ( buffer.size() < tp_length->value + tp_length->length )
			return result;

		buffer = buffer.subspan(tp_length->value + tp_length->length);
	}

	for ( auto const &id : parameter_ids )
		{
		// Probably will have to change this for older distributions.
		result->Append(zeek::make_intrusive<zeek::StringVal>(std::format("({:02x})", id)));
		}

	return result;
	%}
